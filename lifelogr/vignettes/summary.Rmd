---
title: "Summary"
date: "2017-03-21"
output: 
  pdf_document:
    fig_width: 3.5
    fig_height: 1.9
urlcolor: blue

vignette: >
  %\VignetteIndexEntry{Summary}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEngine{knitr::knitr}
  %\VignetteEncoding{UTF-8}
---

```{r, echo = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```


```{r, eval = FALSE}
vignette("Report", package = "lifelogr")
```


```{r}
library(lifelogr)
```

[Lifelogging](http://lifestreamblog.com/lifelogging/) is the "process of 
tracking personal data generated by our own behavioral activities."  Examples of
lifelogging include tracking one's exercise and sleep. While devices like 
iPhones and Fitbits make collecting data on oneself easy, analyzing and 
interpreting that data is more difficult.

The lifelogr package makes life logging analysis and interpretation easy by:

- Providing a framework for working with multiple sources of personal data.
- Allowing users to easily create three sets of meaningful visualizations.
- Creating an ecosystem for experimentation - a feedback loop between self-data, and the process generating it.

## Working with Multiple Sources of Data: the "Person" class

This package is built around the Person class, an R6 class. An object of Person class encapsulates a complete picture of a user, as seen through her data. The goal of this class is to make working with multiple sources of data as easy as possible by joining and standardizing multiple datasets. Users can then access the data from and across sources for visualization and experimentation.

Upon instantiation, a user can provide information about himself, the filepath to a csv file with Apple data, Fitbit account information, and/or dataframes of data from other sources.

### Loading Multi-Source Data into Person Objects

Fitbit users can provide their account username and password upon instantiation. We use functions from the fitbitScraper package to collect all of a user's Fitbit data between the start and end date of interest.
```{r, eval = FALSE}
EX <- Person$new(fitbit_user_email = "example@domain.com", 
                 fitbit_user_pw = "password",
                 apple_data_file = "apple.csv",
                 addl_data = NA,
                 user_info = list("name" = "EX", "age" = 29, "gender" = "male"),
                 target_steps = 10000,
                 group_assignments = list(data.frame(NA), data.frame(NA)),
                 start_date = "2017-01-19", end_date = "2017-02-17")
```

```{r, echo = FALSE}
load("../data/EX.rda")
```

iPhone users can provide a filepath to a csv with their Apple health data. Users can download their data using an iOS app called QS Access (quantified self), which allows for selection of variables and time scales (by day or by hour), to include in a csv file. For greater compatibility with the lifelogr package, users are highly recommended to select the "by hour" time interval.

Users can provide data from other sources and self-tracking apps as pre-cleaned dataframes in the `addl_data` or `addl_data2` arguments. To make maximal use of lifelogr's functions, the column names of the same variables in the dataframe should match those referenced in the Person class, and class documentation (when the variables in the dataframe are the same as those referred to in the documentation).

### Example of Person Class

EX is an example of a Person class for a user who provided their Fitbit account information upon instantiation. Functions within the Person class gathered and manipulated the data into data from three main "sources":

* `fitbit_daily` has Fitbit data recorded on a daily basis
* `fitbit_intraday` has Fitbit data recorded on an intraday basis, generally 
  every 15 minutes, although for certain variables, such as heart rate, data are 
  recorded every 5 minutes.
*  `fitbit_util` has information about the dates in the range specified 
  by the user upon Person instantiation, such as which day of the week a specific date is.
  
  
### Dates, Times, and Date-Times

Dates and times come in numerous forms. lifelogr recognizes three types of
dates/times as acceptable time-related variables to join datasets on:

* date: "2017-03-20"
* time: "08:00:00"
* datetime: "2017-03-20 08:00:00", a combination of a date and a time

Upon instantiation, the Person class automatically converts and renames Fitbit and Apple health data to adhere to this variable naming and format convention. If users provide their own addl_data as dataframes, they will need to have one or more of these time-related variables as columns in their dataframes in order to be able to join across their data source, and Fitbit/Apple health data.

## Visualization

There are 3 functions which allow for a series of plots with just one function
call: `plot_sleep_all`, `plot_daily_all`, and `plot_intraday_all`.  Each acts 
like the `plot.lm` function, where users must click "enter" to see the next plot.

Each plot within each of the three series can also be generated individually with a call to its appropriate plot function.

For example, using `plot_sleep_all` to generate all the sleep plots for EX:
```{r, fig.show = "hold"}
plot_sleep_all(EX)
```

Calling `plot_daily_all` and `plot_intraday_all` will result in similar series
of plots.

Users can also call each function individually using 
`plot_sleep(person, plot_type)` (or `plot_daily` or `plot_intraday`), and also 
pass in other arguments for plots with other arguments.

For example:
```{r}
plot_sleep(EX, "by_start_end_time", "day_of_week")
```

Using `plot_daily`:
```{r}
plot_daily(EX, "steps")
```

Using `plot_intraday`:
The default is for `plot_intraday` to group the data by time intervals 
within each day so that data for a "typical day" is displayed.
```{r}
plot_intraday(EX, "distance", unit = "km")
```

However, it is also possible to specify that the plots use the raw data and plot
over all datetimes.

```{r}
plot_intraday(EX, "bpm", FALSE)
```

## Experimentation Framework

To promote an interaction and exchange between a user's life and lifestyle and self-data, data and the process generating it (the user!)

While almost all the visualizations shown above had date, date-time, or time on 
the x axis, the experimentation framework allows for greater flexibility.  Users
can select any variables of interest and examine their relationship.

Users can specify
* x variables of interest
* y measures of interest
* type of analysis ("plot", "correlation", "anova", "compare_groups", or 
"regression")
* time variable (date, time, or datetime)

The `experiment` function will study every pairwise combination of the variable
and measure variables given.

Each analysis can also be done individually using `l_plot`, `correlation`, `l_anova`, 
`compare_groups`, or `l_regression` instead of using `experiment`.

1.  Plots

    To plot the relationship between sleep duration and resting heart 
    rate and the relationship between day of week and resting heart rate on a 
    date basis:
    ```{r, fig.show = "hold"}
    experiment(person = EX, 
               variables = list("fitbit_daily" = c("sleepDuration"),
                                "util" = c("day_of_week")),
               measures = list("fitbit_daily" = c("restingHeartRate")), 
               analysis = c("plot"),
               time_var = c("date"))
    ```

2.  Correlation

    To calculate the correlation between sleep duration and number of steps on
    a date basis:
    ```{r}
    experiment(person = EX,
               variables = list("fitbit_daily" = c("sleepDuration")),
               measures = list("fitbit_intraday" = c("distance")),
               analysis = c("correlation"),
               time_var = c("date"))
    ```
  `l_plot` will generate the same result:
    ```{r}
        dataset <- create_dataset(person = EX,
                                  all_variables = list("fitbit_daily" = c("sleepDuration"),
                                                       "fitbit_intraday" = c("distance")), 
                                  time_var = c("date"))
        
        correlation_df <- correlation(dataset, person = EX, 
                                      variables = list("fitbit_daily" = c("sleepDuration")),
                                      measures = list("fitbit_intraday" = c("distance")),
                                      time_var = "date")
    ```


3.  ANOVA

    To create ANOVAs for the effect of sleep duration and steps on resting
    heart rate on a date basis:
    ```{r}
    experiment(person = EX,
               variables = list("fitbit_daily" = c("sleepDuration", "steps")),
               measures = list("fitbit_daily" = c("restingHeartRate")),
               analysis = c("anova"),
               time_var = c("date"))
    ```

4.  Compare Groups

    To compare across time variables not already defined, such as months, users
    can set up groups.  Groups must be part of the Person instance, so it is 
    oftentimes easier to just use `compare_groups`.
    
    In this case, only data from January and February is
    in the sample instance of Person, so only two groups are compared:
    ```{r}
     dataset <- create_dataset(person = EX,
                          all_variables = list("util" = c("month"), 
                                               "fitbit_daily" = 
                                                 c("sleepDuration", 
                                                   "steps",
                                                   "restingHeartRate")), 
                          time_var = c("date"))

    indiv_months <- data.frame("month" = c("Jan", "Feb", "Mar", "Apr", "May",
                                          "Jun", "Jul", "Aug",
                                          "Sep", "Oct", "Nov", "Dec"),
                               "group" = c(1:12))
    
    compare_groups(dataset, person = EX, 
                         addl_grouping_assignments = list("indiv_months" = 
                                                            indiv_months), 
                         names_of_groupings = c("indiv_months"),
                         variables_to_compare = c("steps", "restingHeartRate"))
    ```

5.  Regression

    To run a regression of resting heart rate on steps ^ 2
    ```{r}
    experiment(person = EX,
                   variables = list("fitbit_daily" = c("steps")),
                   measures = list("fitbit_daily" = c("restingHeartRate")),
                   analysis = c("regression"),
                   time_var = c("date"))
    ```

Easy for users to write their own functions using these as a template, using the 
cleaned dataframes in their Person object, and the create_dataset function, which joins data across sources into one dataframe.

## Shiny Application

## Apple Data

## Reflections

In our proposal, we explained that our package would accomplish 5 tasks:

1.  Data matching
2.  Visualization
3.  Analysis
4.  Recommendations
5.  Experimentation

We had to scale back on our proposal, after discovering the complexity of fitbit
data.  We chose to create an R6 class to create Person objects representing each
user.  We built upon another package called fitbitScraper, which scrapes from
fitbit's website.  Functions from this package only pull portions of the data.
We had to create functions to pull as much of the data as possible and join it
together.

We successfully created functions allowing the user to easily visualize certain
measures and run a series of experiments.  We created a framework for users to
add whatever additional data they want and then analyze it.

Future work can involve providing recommendations and the ability to visually
compare measures.  Creating recommendation functionality is difficult because
it generally involves a human.  A package can tell its user that his/her resting 
heart rate is too high or that s/he is not meeting his/her step count, but
providing recommendations for how to solve that issue is more difficult.
Fitbit does not claim to be a replacement for a doctor, and neither does this
package.